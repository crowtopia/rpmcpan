#!/usr/bin/perl -w

use strict;
use warnings;
use Path::Class;
use Getopt::Long;
use Try::Tiny;
use Cwd;
use List::Util qw(first);
use IPC::System::Simple qw(runx capturex);
use v5.10.1;

# Specify all RPMs required by this script.
# RPM: rpm-build
# RPM: spectool
# RPM: perl
# RPM: perl(IPC::System::Simple)
# RPM: perl(Path::Class)
# RPM: perl(Try::Tiny)
# RPM: perl(List::Util)

Getopt::Long::Configure (qw(bundling));
Getopt::Long::GetOptions(
    'path|p=s'   => \my $path,
    'prefix|f=s' => \my $prefix,
    'dist|d=s'   => \my $dist,
    'all'        => \my $all,
    'verbose|v!' => \my $verbose,
    'spec|s=s@'  => \my @specs,
);

# Establish the major Perl version we're building.
my @qflag = ($verbose ? () : '--quiet');
my $version = capturex 'rpm', @qflag, qw(-q --qf %{version} --specfile SPECS/perl.spec);
$version =~ s/^5[.](\d+).+/5$1/;

$path   //= "/usr/local/perl$version";
$prefix //= "perl$version";
$dist   //= '';

my $dest      = dir 'repo';
my $tmp       = dir +File::Spec->tmpdir;
my $branch    = find_branch();
my $hash_file = $tmp->file("${prefix}-$dist-$branch.hash");
my $git_hash  = capturex qw(git log --format=%H -1);
chomp $git_hash;

# Define the RPM macros we set.
my %macros = (
    _prefix         => $path,
    iov_prefix      => $prefix,
    __perl          => "$path/bin/perl",
    _topdir         => cwd,
    __find_requires => "bin/filter-requires $prefix",
    __find_provides => "bin/filter-provides $prefix",
    _use_internal_dependency_generator =>  0,
    ($dist ? ('--define' => "dist $dist") : ()),
);

my %specs = map {
    (my $rpm = $_->basename) =~ s/[.]spec$//;
    $rpm =~ s/^(?:perl-?\b)?/$prefix-/;
    $rpm => $_
} @specs ? (map { file $_ } @specs) : grep {
    !$_->is_dir && $_->basename =~ /[.]spec$/
} -e $hash_file && !$all ? do {
    my $prev_hash = $hash_file->slurp(chomp => 1);

    # Clean up deleted RPMs.
    if (-e $dest) {
        for my $rm (capturex qw(git diff --name-only --diff-filter=D), $prev_hash, '--', 'SPECS') {
            # We have deleted SPEC files. Delete the corresponding RPMs.
            chomp $rm;
            (my $rpm = file($rm)->basename) =~ s/[.]spec$//;
            $rpm =~ s/^(?:perl-?\b)?/$prefix-/;
            rm_rpms($rpm);
        }

        # Get a list of only modifed SPEC files.
        my %add = map {; chomp; $_ => file $_ } capturex(
            qw(git diff --name-only --diff-filter=ACMR), $prev_hash, '--', 'SPECS'
        );


        # Now add any that have no corresponding RPMs in the destination directory.
        for my $spec (dir('SPECS')->children) {
            next if $add{$spec};
            my $file = file $spec;
            (my $rpm = $file->basename) =~ s/[.]spec$//;
            $rpm =~ s/^(?:perl-?\b)?/$prefix-/;
            $add{$spec} = $file unless try { capturex 'rpm', @qflag, $rpm; 1 };
        }

        # Return them all.
        values %add;
    } else {
        # Make sure we have a destination directory, then build everything.
        $dest->mkpath;
        dir('SPECS')->children;
    }
} : do {
    # Gonna rebuild everything.
    $dest->rmtree;
    $dest->mkpath;
    dir('SPECS')->children;
};

unless (%specs) {
    say "No spec files updated since $git_hash, nothing to do";
    save_hash();
    exit 0;
}

# http://cpansearch.perl.org/src/CWEST/ppt-0.14/bin/tsort
my (%failed, %pairs, %npred, %succ);
for my $rpm (sort keys %specs) {
    my $spec = $specs{$rpm};
    say "* Determining dependencies specified in ", $spec->basename;

    # Open the spec file.
    my $fh = $spec->open('<:encoding(UTF_8)') or do {
        warn "Cannot open $spec: $!\n";
        $failed{$rpm} = 1;
        next;
    };

    # Find dependencies.
    while (<$fh>) {
        next unless s/^BuildRequires:\s+//i;
        (my $dep = $_) =~ s/\s+$//;
        $dep =~ s/[%]{([^}]+)}/$macros{$1} || $1/ge;
        next if defined $pairs{$rpm}{$dep};
        $pairs{$rpm}{$dep}++;
        $npred {$rpm} += 0;
        ++$npred{$dep};
        push @{$succ{$rpm}}, $dep;
    }
}

# create a list of RPMs without predecessors
my @list = grep {!$npred{$_}} keys %npred;

my @prereqs;
while (@list) {
    my $next = pop @list;
    push @prereqs => $next;
    foreach my $child (@{$succ{$next}}) {
        # depth-first
        push @list, $child unless --$npred{$child};
    }
}

while (@prereqs) {
    my @to_install;
    while (@prereqs) {
        my $req = pop @prereqs;
        if (my $spec = delete $specs{$req}) {
            # It's something we need to build.
            if (@to_install) {
                # Install prereqs.
                say 'Installing Yum dependencies: ', join ' ', @to_install;
                runx qw(sudo yum install -y), @qflag, @to_install;
                @to_install = ();
            }
            # Build it.
            build($req => $spec);
        } else {
            # Add it to the list of dependencies to build.
            push @to_install => $req;
        }
    }
}

# Build any remaining RPMs.
build($_ => $specs{$_}) for keys %specs;

# Wrap things up.
if (%failed) {
    say "FAILED: $_" for sort keys %failed;
    exit +(keys %failed) + 0;
} else {
    save_hash();
    exit 0;
}

sub build {
    my ($rpm, $spec) = @_;
    return if $failed{$rpm};

    my @params = (
        @qflag,
        (map {; '--define' => "$_ $macros{$_}" } keys %macros),
        $spec,
    );

    try {
        # Download sources.
        say "* Downloading sources for $rpm";
        runx qw(spectool -S -C SOURCES -g), @params;

        # Remove previous builds.
        rm_rpms($rpm);

        say "* Building $rpm";
        runx qw(rpmbuild -ba), @params;

        # Find all new RPMs and put them into the repo directory.
        dir('RPMS')->recurse(callback => sub {
            my $f = shift;
            my $bn = $f->basename;
            return if $f->is_dir || $bn !~ /[.]rpm$/;
            say "  - Collecting and installing $bn";
            my $archive = $dest->file($bn);
            rename $f, $archive;
            runx qw(sudo rpm -Uvh --replacepkgs --replacefiles), $archive;
        });
    } catch {
        warn $_;
        $failed{$rpm} = 1;
    };
}

sub rm_rpms {
    my $rpm = shift;
    say "* Removing previous builds for $rpm";
    for my $rpm_file (find_rpms($rpm)) {
        say "    rm $rpm_file";
        $rpm_file->remove;
    }
}

sub find_rpms {
    my $rpm = shift;
    my $name_re = qr/^\Q$rpm\E-\d/;
    return grep { !$_->is_dir && $_->basename =~ $name_re } $dest->children;
}

sub save_hash {
    my $fh = $hash_file->openw;
    print $fh $git_hash;
    $fh->close;
}

sub find_branch {
    my @lines = capturex 'git', qw(branch -a --contains HEAD)
        or die "Cannot detect current git branch; use --git-branch\n";

    if (my $line = first {/^[*]\s.+$/ } @lines) {
        # Return the branch unless it's detached.
        chomp $line;
        $line =~ s/^[*]\s//;
        return $line unless $line eq '(no branch)';
    }

    if (my $line = first { $_ !~ m{/} && $_ !~ /^[*]/ } @lines) {
        # HEAD is from a local branch.
        chomp $line;
        $line =~ s/^\s+//;
        return $line;
    }

    if (my $line = first { m{/} && $_ !~ /^[*]/ } @lines) {
        # It's a remote branch. Keep only the last part of the name.
        chomp $line;
        $line =~ s/^\s+//;
        return $1 if $line =~ m{([^/]+)$};
    }

    die "Cannot detect current git branch; use --git-branch\n"
}
